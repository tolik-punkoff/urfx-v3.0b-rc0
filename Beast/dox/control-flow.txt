instead of "IF ... ELSE ... ENDIF" you should use:
  ?< ... || ... >?

i like this syntax more than "IF/ENDIF" (and "IF" is not even included in
the normal system wordset).

there are some special forms of condition checks:

  0?<   -- "0= ?<"
  not?< -- "0= ?<"
  -?<   -- "0< ?<"
  +?<   -- "0> ?<"
  -0?<  -- "0<= ?<"
  +0?<  -- "0>= ?<"

you can add "exit" after "?" to indicate that Beast should automatically
compile "EXIT" as the last word of a cond body. such conditionals cannot
have "else" part.

  ?exit< ... >?

is exactly the same as:

  ?< ... exit >?

but it is easier to read: you don't have to scan the source code for
"exit". ;-)


loops, case, etc.
=================

all loop and case contstructs are replaced with generalised Parnas' loop
iterator.

<< cond [COR cond]* [CAND cond]* ?^| ... |?
   cond [COR cond]* [CAND cond]* ?v| ... |?
   else| ...
>>

i omited `init` predicate, because in Forth it is easy to factor it into
separate word (much easier than in other languages), and implementing
`init` efficiently requires extra branch at "<<". actually, several chained
branches, tracking of `init` in conditions, and such.

note that COR and CAND are "short-circuit", jumping directly to the
corresponding "?.|" (or after the respective "|"). this nicely (and
efficiently) solves the problem with short-circuit boolean evaluation
without introducing a new control structure.

the last predicate should be either "else|", or non-conditional arrow
("^|" or "v|"). the compiler will complain if you forget about it.

you can use "^| ... |", or slightly more optimal "^||" as the last
predicate. of course, down arrow is allowed too. it is your responsbility
to not write any code after unconditional arrow (you can do it, but it is
completely useless).

one useful extension is "nested checks". it can be used to avoid
unnecessary stack manipulations, and carrying some flag around.

  ?<| some-code |>

this can be used instead of any "?.| ... |", and can be nested. this
"substructure" can contain futher checks, which repeat or exit the parent
"<< ... >>". this allows to factor the common part of several guard
expressions, evaluate it only once, and avoid passing it around (hence
eliminating extra stack manipulation).

  somecond ?<|
    cond1 ?^| ... |?
    cond2 ?v| ... |?
  |>

there is no BREAK/CONTINUE for this control structure.

if your branches has no code, it is slightly more efficient to use "?^||"
and "^v||" words.

it is also possible to use "of?^|", "of?v|" and so on to implement "CASE".
it works as an ordinary "CASE" (i.e. drops the value on successfull check).

  << 3 of?v| ." the value is 3" |?
     6 of?v| ." the value is 6" |?
  else| ." the value is: " . >>

there is "?of?.|" construct. it expects the prepared condition. it can be
used to check ranges, or to perform other non-standard tests:

  dup 1 3 within ?of?v| ... |?
  dup 5 > ?of?v| ... |?

note the "DUP" -- you have to keep the value you are testing. basically,
"n of?.|" is just an optimised "dup n = ?of?.|".


"FOR" loops
===========

there is "FOR" iterator. it is using separate stack for temporary values
(not return stack, as most other systems do). it is also different from the
standard "FOR" word. it should be finished with "ENDFOR".

  FOR  ( count )

it executes the loop "count" times. loop index starts from 0. i.e.

  3 FOR i . ENDFOR

will print: "0 1 2 ".

if `count` is zero or negative, the whole loop will be skipped.

it is not recommended to use this loop form, though, and it may disappear
in future Beast revisions.
