;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; and now for something completely different...
;; UrForth/Beast: Devastator -- Succubus
;; Copyright (C) 2023-2024 Ketmar Dark // Invisible Vector
;; see LICENSE.txt for license terms
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; optimising x86 native code compiler
;; machine instruction length tracking
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(*
for optimiser (and inliner) to work reliably, we need to record the length
of each compiled native instruction. this allows us to travel back and
forth in the instruction stream without full instruction decoding. fast,
reliable, easy to implement.

instruction info is 2 bytes: low byte is instruction length, high byte is
instruction type.
*)

module ilendb
<disable-hash>
<published-words>

6 constant sswap-len  \ 2 for old code

;; instruction types
enum{
  def: it-normal
  def: it-sswap
  \ ORDER MATTERS!
  def: it-jdisp     -- call, jmp, jcond: both 8-bit and 32-bit disps
  def: it-push-ebx
  def: it-push-eax
  def: it-pop-ebx
  def: it-pop-eax
  def: it-push-imm
  def: it-ret
  \ the above used with "bounds"
  def: it-#-load        -- either "xor ebx, ebx" or "mov ebx, # value"
  def: it-#-load-eax    -- either "xor eax, eax" or "mov eax, # value"
  def: it-mov-eax-ebx   -- this is generated by inliner, and precedes literal loading into ebx
  def: it-swap-eax-ebx  -- this is generated by inliner, uses EDX as temp register
  def: it-nop-align
  def: it-0max          -- pseudoprimitive, generated by inliner
  \ some primitives (as a whole)
  def: it-prim-idiv
  def: it-prim-imod
  def: it-prim-max
  def: it-prim-umod
  def: it-prim-ndrop
  def: it-prim-nrdrop
  def: it-prim-rpush
  def: it-prim-rpop
  \ def: it-ret-jpad  -- ret with jump pad
}

;; bblock start bit in table entry type
\ $8000 constant it-word-bblock-bit

;; bblock start bit in type byte
$80 constant it-bblock-bit
$7F constant it-type-mask


<private-words>
;; we will record everything to the temporary buffer.
;; this buffer will be stored in header segment when
;; word compilation is complete. it is dynamically allocated.
;; buffer simply holds byte lengthes. starting address is
;; known to the caller, and there is no need to record it.
;; 16KB is more than enough for any word.
;; first and last 4 bytes are reserved.
16376 constant #buffer
0 quan buffer
;; index in the buffer (NOT offset!)
0 quan bufidx


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<private-words>

4096 constant #page

;; also, allocate two guard pages, and mark them as inaccessible
: alloc-one-buffer  ( size -- addr )
  8 + #page + 1- #page 1- ~and #page + dup #page +
  linux:prot-r/w linux:mmap not?error" out of memory for optimiser"
  dup #page linux:prot-none linux:mprotect drop
  ( full-size-4096 addr )
  #page + tuck 2dup + #page - #page linux:prot-none linux:mprotect drop
  ( addr full-size addr )
  ;; setup guards
  + #page - 4- !0  dup !0 ;

: ensure-buffer
  buffer not?< #buffer alloc-one-buffer 4+ buffer:! >? ;


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<published-words>

: iw-len     ( ilenw -- len )  lo-byte ;
: iw-type    ( ilenw -- type )  hi-byte it-type-mask and ;
: iw-type!   ( type ilenw -- ilenw )  lo-byte swap 256 * + ;
: iw-bblock ( ilenw -- bblock? )  hi-byte it-bblock-bit mask? ;
\ : iw-bblock! ( ilenw -- ilenw )  it-word-bblock-bit or ;

;; record instruction length
;; let it segfault on out-of-bounds access
: len,  ( iw )
  dup not?< drop || bufidx buffer dw-nth w! bufidx:1+! >? ;

;; return number of lengthes recorded
: #total  ( -- #total )  bufidx ;

: nth-iw@  ( idx -- iw )  buffer dw-nth w@ ;
: last-iw@  ( -- iw )  bufidx 1- nth-iw@ ;
: prev-last-iw@  ( -- iw )  bufidx 2- nth-iw@ ;
: nth-last-iw@  ( idx -- iw )  bufidx swap - 0 max 1- nth-iw@ ;

: nth-type@  ( idx -- type )  nth-iw@ iw-type ;
: last-type@  ( -- type )  last-iw@ iw-type ;
: prev-last-type@  ( -- type )  prev-last-iw@ iw-type ;
: nth-last-type@  ( idx -- type )  nth-last-iw@ iw-type ;

: nth-bblock@  ( idx -- type )  nth-iw@ iw-bblock ;
: last-bblock@  ( -- type )  last-iw@ iw-bblock ;
: prev-last-bblock@  ( -- type )  prev-last-iw@ iw-bblock ;
: nth-last-bblock@  ( idx -- type )  nth-last-iw@ iw-bblock ;

: nth-len@  ( idx -- type )  nth-iw@ iw-len ;
: last-len@  ( -- type )  last-iw@ iw-len ;
: prev-last-len@  ( -- type )  prev-last-iw@ iw-len ;
: nth-last-len@  ( idx -- type )  nth-last-iw@ iw-len ;

;; drop last recorded length
: drop  bufidx 1- 0 max bufidx:! ;

;; assume that iidx is valid
: remove-last-nth  ( iidx )
  bufidx:1-!                  ;; we'll need it everywhere anyway
  bufidx swap - buffer dw-nth ;; to
  dup 2+                      ;; from
  swap                        ;; for cmove: from to
  bufidx 2*                   ;; count
  cmove ;


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<private-words>

0 quan istart-addr


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
<published-words>

;; call before first use
: initialise  buffer:!0 bufidx:!0 ;

: wipe     bufidx:!0 ;
: restart  ensure-buffer wipe ;

: cg-begin-at   ( code-addr )  istart-addr:! ;
: cg-begin-here ( -- code-addr )  istart-addr ;

;; i don't want to count cg instruction lengthes manually ;-)
: cg-begin    code-here cg-begin-at ;
: cg-end      code-here istart-addr - len, ;

: cg-end-typed  ( type ) code-here istart-addr -  iw-type!  len, ;

: cg-end-ret    it-ret cg-end-typed ;
: cg-end-sswap  it-sswap cg-end-typed ;
: cg-end-jdisp  it-jdisp cg-end-typed ;


seal-module
end-module ilendb (published)
