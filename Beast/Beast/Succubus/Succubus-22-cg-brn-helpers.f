;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; and now for something completely different...
;; UrForth/Beast: Devastator -- Succubus
;; Copyright (C) 2023-2024 Ketmar Dark // Invisible Vector
;; see LICENSE.txt for license terms
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; optimising x86 native code compiler
;; branch optimiser tables and helper words
;; directly included from "Succubus-24-cg-high.f"
;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; branch optimiser tables
;;
;; "c-none" is used as "default"
;; format:
;;   dd c-XXX
;;     dd repl-opcodes (0 length means "end", and other bytes is new jump condition)
<private-words>


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (tbranch), (0branch)

<normal> <i-order>
<normal> <b-order>
;; jump if condition satisfied (utos <> 0)
create tbranch-conds
;; no branch optimisation, EBX is the flag
cdetect:c-none ,  <i-table>
  test  utos, utos
  <i-done>
  xasm:cond:nz ,
cdetect:c-= ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:e ,
cdetect:c-<> ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:ne ,
cdetect:c-< ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:l ,
cdetect:c-<= ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:le ,
cdetect:c-> ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:g ,
cdetect:c->= ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:ge ,
cdetect:c-u< ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:b ,
cdetect:c-u<= ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:be ,
cdetect:c-u> ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:a ,
cdetect:c-u>= ,  <i-table>
  cmp   eax, utos
  <i-done>
  xasm:cond:ae ,

;; ~and tbranch -- remove "test"
cdetect:c-~and ,  <i-table>
  not   utos
  test  eax, utos
  <i-done>
  xasm:cond:nz ,
;; and tbranch -- remove "test"
cdetect:c-and ,  <i-table>
  test  eax, utos
  <i-done>
  xasm:cond:nz ,
;; or tbranch -- remove "test"
cdetect:c-or ,  <i-table>
  or    eax, utos
  <i-done>
  xasm:cond:nz ,
;; xor tbranch -- remove "test"
cdetect:c-xor ,  <i-table>
  xor   eax, utos
  <i-done>
  xasm:cond:nz ,

cdetect:c-not-mask? ,  <i-table>
  test  eax, utos
  <i-done>
  xasm:cond:z ,
cdetect:c-mask? ,  <i-table>
  test  eax, utos
  <i-done>
  xasm:cond:nz ,
cdetect:c-not-~mask? ,  <i-table>
  not   utos
  test  eax, utos
  <i-done>
  xasm:cond:z ,
cdetect:c-~mask? ,  <i-table>
  not   utos
  test  eax, utos
  <i-done>
  xasm:cond:nz ,

cdetect:c-0= ,  <i-table>
  test  utos, utos
  <i-done>
  xasm:cond:z ,
cdetect:c-0<> ,  <i-table>
  test  utos, utos
  <i-done>
  xasm:cond:nz ,
cdetect:c-0< ,  <i-table>
  test  utos, utos
  <i-done>
  xasm:cond:s ,
cdetect:c-0> ,  <i-table>
  cmp   utos, # 0
  <i-done>
  xasm:cond:g ,
cdetect:c-0<= ,  <i-table>
  cmp   utos, # 0
  <i-done>
  xasm:cond:l ,
cdetect:c-0>= ,  <i-table>
  test  utos, utos
  <i-done>
  xasm:cond:ns ,

;; "end of table" guard value
-1 ,
create;


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; internal branch optimiser words

 true constant bropt-active?
false constant bropt-debug?


: skip-repl-rec  ( rrec^ -- next-rrec^ )
  4+ ;; skip c-code
  << @++ $01_00_00_00 u>= ?^|| else| >> ;

: find-repl  ( tbl^ c-code -- rec^//0 )
  swap << 2dup @ = ?v| nip 4+ |?
          dup @ -?v| 2drop 0 |?
       ^| skip-repl-rec | >> ;


0 quan (#)-cmp-addr
0 quan (#)-cmp-value

|: prev-cmp-lit?  ( -- flag )
  ilendb:prev-last-type@ ilendb:it-#-load = not?exit&leave
  code-here ilendb:prev-last-len@ 2 = ?< 4- (#)-cmp-addr:! (#)-cmp-value:!0
  || 7 - dup (#)-cmp-addr:! 1+ code-@ (#)-cmp-value:! >? true ;

;; this is generated by inliner instead of "push ebx / load-lit / pop eax"
|: prev-prev-mov-eax-ebx?  ( -- bool-flag )
  2 ilendb:nth-last-type@ ilendb:it-mov-eax-ebx = ;

;; generator: ( reg value )
vect brxoptim-cmp-gen
false quan brxoptim-cmp-nondestructive?

|: brxoptim-lit-detect-xop  ( -- gen-cfa // 0 )
  \ ilendb:last-len@ 2 = not?exit&leave -- done by the caller
  brxoptim-cmp-nondestructive?:!t
  code-here 2- code-w@
  dup $C3_3B = ?exit< drop ['] low:cmp-reg32,value >?
  dup $C3_0B = ?exit< drop ['] low:or-reg32,value brxoptim-cmp-nondestructive?:!f >?
  dup $C3_33 = ?exit< drop ['] low:xor-reg32,value brxoptim-cmp-nondestructive?:!f >?
  dup $D8_85 = ?exit< drop ['] low:test-reg32,value >?
  dup $C3_85 = ?exit< drop ['] low:test-reg32,value >?
      $C3_23 = ?exit< ['] low:and-reg32,value brxoptim-cmp-nondestructive?:!f >?
  0 ;

|: brxoptim-lit-remove-push-ebx  ( gen-pop-tos? -- gen-pop-tos? )
  ;; it is non-destructive, check if we can remove "push ebx"
  ilendb:last-type@ ilendb:it-push-ebx = not?exit
  low:can-remove-last? not?exit
  low:remove-last-unsafe
  ( do not generate "pop ebx") drop false ;

;; replace " mov ebx, # n / cmp eax, ebx" with "cmp eax, # n"
;; another fun optimisation: "push ebx / cmp ebx, # lit / pop ebx" -- push/pop is not necessary here
: brxoptim-cmp-lit  ( gen-pop-tos? -- gen-pop-tos? )
  ilendb:last-len@ 2 = not?exit
  brxoptim-lit-detect-xop dup brxoptim-cmp-gen:! not?exit
  prev-cmp-lit? not?exit
  prev-prev-mov-eax-ebx?
\ dup ?< endcr ." LITCMP: mov detected!\n" >?
  dup 2* (#)-cmp-addr + ( backup two bytes) bblock-start^ u< ?exit< drop >?
\ endcr ." LIT-CMP! lit=" (#)-cmp-value . (#)-cmp-value .hex8 cr
  ;; remove CMP and literal load
  low:remove-last-unsafe low:remove-last-unsafe
  ;; generate direct cmp
  ?< \ endcr ." removed MOV EAX, EBX\n"
    low:remove-last-unsafe  ;; remove "mov eax, ebx"
    ;; we are wiped everything, and will perform operation on EBX
    brxoptim-cmp-nondestructive? ?< brxoptim-lit-remove-push-ebx >?
    low:ebx
  || low:eax >?
  (#)-cmp-value brxoptim-cmp-gen
  stat-logbranch-litcmp:1+! ;


|: brxoptim-esp+4-detect-xop  ( -- gen-cfa // 0 )
  \ ilendb:last-len@ 2 = not?exit&leave -- done by the caller
  code-here 2- code-w@
  dup $C3_3B = ?exit< drop ['] low:cmp-[esp+value],ebx >?
  dup $D8_85 = ?exit< drop ['] low:test-[esp+value],ebx >?
      $C3_85 = ?exit< ['] low:test-[esp+value],ebx >?
  0 ;

;; sometimes the code looks like this:
;;   push    ebx
;;   mov     eax, [esp+4]
;;   cmp     eax, ebx
;;   pop     ebx  -- generated by the outer code
;; replace with:
;;   cmp     [esp], ebx
: brxoptim-push-ebx-[esp+4]-pop-ebx  ( gen-pop-tos? -- gen-pop-tos? )
  ilendb:last-len@ 2 = not?exit
  ilendb:prev-last-len@ 4 = not?exit
  2 ilendb:nth-last-type@ ilendb:it-push-ebx = not?exit
  code-here 7 - bblock-start^ u>= not?exit
  \ code-here 2- code-w@ $C3_3B = not?exit
  code-here 6 - code-@ $04_24_44_8B = not?exit
  brxoptim-esp+4-detect-xop dup brxoptim-cmp-gen:! not?exit
\ endcr ." !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! at " code-here .hex8 cr
  low:remove-last-unsafe low:remove-last-unsafe low:remove-last-unsafe
  \ 0 low:cmp-[esp+value],ebx
  0 brxoptim-cmp-gen
  ( do not generate "pop tos") drop false
  stat-logbranch-push-pop-tos:1+! ;

: rollback-code
  code-here cdetect:instr^ -
  dup ?<
    [ bropt-debug? ] [IF]
      bropt-active? ?< endcr ."    rolling back " dup ., ." bytes.\n" >?
    [ENDIF]
    dup code-unallot >? drop ;

: rollback-ilendb
  cdetect:#instr
  [ bropt-debug? ] [IF]
    bropt-active? ?< endcr ."    rolling back " dup ., ." instructions.\n" >?
  [ENDIF]
  << dup ?^| ilendb:drop 1- |? else| drop >> ;

: repl-rec-gen-opcode  ( opcode )
  [ bropt-debug? ] [IF]
    bropt-active? ?< endcr ."   OPC: $" dup .hex8 cr >?
  [ENDIF]
  dup 24 rshift dup ilendb:len,  ( opcode len )
  swap << dup lo-byte code-db, 1 under- over ?^| 256 u/ |? else| 2drop >> ;

: repl-rec-generate  ( rec^ -- jump-cond )
  << @++ dup $01_00_00_00 u>= ?^| repl-rec-gen-opcode |? else| nip >> ;

: repl-rec-rewrite  ( gen-pop-tos? rec^ -- gen-pop-tos? jump-cond )
  rollback-code rollback-ilendb repl-rec-generate
  over ?<
    swap
    brxoptim-cmp-lit
    brxoptim-push-ebx-[esp+4]-pop-ebx
    swap >? ;


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; some branches looks like: "push ebx / ebx manipulation / pop ebx".
;; we can rewrite 'em with direct instructions, and remove push/pop.
;; it is guaranteed that we don't hit basic block boundary with cmp.
;; (but not with the other instructions!)

enum{
  def: brcmp-unknown  -- must be 0!
  def: brcmp-test-ebx,ebx
  def: brcmp-cmp-eax,ebx
  def: brcmp-cmp-ebx,lit
  \ def: brcmp-and-ebx,lit
  ;; special, created by rewriter, never seen in the wild
  \ def: brcmp-cmp-ebx,[addr]
}

0 quan br-cmp-type
0 quan br-cmp-lit-value

|: br-last-cmp-type-2-bytes  ( -- cmp-type )
  code-here 2- code-w@
  dup $DB_85 = ?exit< drop brcmp-test-ebx,ebx >?
  $C3_3B = ?< brcmp-cmp-eax,ebx || false >? ;

|: br-last-cmp-type-3-bytes  ( -- cmp-type )
  code-here 3 - code-w@
  << $FB_83 of?v| brcmp-cmp-ebx,lit |?
     \ $E3_83 of?v| brcmp-and-ebx,lit |?
  else| drop brcmp-unknown exit >>
  code-here 1- code-c@ c>s br-cmp-lit-value:! ;

|: br-last-cmp-type-6-bytes  ( -- cmp-type )
  code-here 6 - code-w@
  << $FB_81 of?v| brcmp-cmp-ebx,lit |?
     \ $E3_81 of?v| brcmp-and-ebx,lit |?
  else| drop brcmp-unknown exit >>
  code-here 4- code-@ br-cmp-lit-value:! ;

|: br-last-compare-type  ( -- cmp-type )
  ilendb:last-len@ dup 2 = ?exit< drop br-last-cmp-type-2-bytes >?
  dup 3 = ?exit< drop br-last-cmp-type-3-bytes >?
  6 = ?exit< br-last-cmp-type-6-bytes >?
  brcmp-unknown ;

0 quan br-precmp-instr^

false quan br-has-push-ebx?

|: br-ebx-load-addr?  ( -- addr TRUE // FALSE )
  ilendb:prev-last-len@ 6 = not?exit&leave
  br-precmp-instr^ code-w@ $1D_8B = not?exit&leave
  br-precmp-instr^ 2+ code-@ true ;

|: br-push-ebx-mov-eax-ebx?  ( -- flag )
  ilendb:prev-last-type@ ilendb:it-push-ebx = not?exit&leave
  ilendb:last-len@ 2 = not?exit&leave
  code-here 2- code-w@ $C3_8B = not?exit&leave
  low:can-remove-last-2? ;


|: br-rewrite-[addr]-compare  ( addr )
\ endcr ." BR-ADDR-COMPARE at $" br-precmp-instr^ 1- .hex8 ."  type=" br-cmp-type 0.r cr
  ;; remove compare, load [addr], push ebx
  low:remove-last-unsafe low:remove-last-unsafe
  br-has-push-ebx? ?< low:remove-last-unsafe >?
  br-cmp-type << ( addr type )
    brcmp-test-ebx,ebx of?v| 0 low:cmp-[addr]-value |?
    brcmp-cmp-eax,ebx of?v|
      br-has-push-ebx? not?<
        ;; this can be preceeded with "push ebx / mov eax, ebx".
        ;; in this case, rewrite "brcmp-cmp-eax,ebx" to "brcmp-cmp-ebx,[addr]"
        br-push-ebx-mov-eax-ebx? ?<
\ endcr ." BR-ADDR-COMPARE-2 at $" br-precmp-instr^ 1- .hex8 ."  type=" br-cmp-type 0.r cr
          low:remove-last-unsafe low:remove-last-unsafe
          low:cmp-ebx-[addr]
          br-has-push-ebx?:!t
        || low:cmp-eax-[addr] >?
      || low:cmp-eax-[addr] >? |?
    brcmp-cmp-ebx,lit of?v| br-cmp-lit-value low:cmp-[addr]-value |?
  else| error" Succubus cannot compare strapons and booze" >>
  br-has-push-ebx? not?exit< pop-tos >? ;


;; don't bother with 32-bit offsets
|: br-ebx-[ebp+n]?  ( -- disp TRUE // FALSE )
  ilendb:prev-last-len@ 3 = not?exit&leave
  br-precmp-instr^ code-w@ $5D_8B = not?exit&leave
  br-precmp-instr^ 2+ code-c@ c>s true ;

;; don't bother with 32-bit offsets
|: br-ebx-[esp+n]?  ( -- disp TRUE // FALSE )
  ilendb:prev-last-len@ dup 3 = ?exit< drop
    br-precmp-instr^ code-@ $FF_FF_FF and $24_1C_8B = ?< 0 true || false >? >?
  4 = not?exit&leave
  br-precmp-instr^ code-@ $FF_FF_FF and $24_5C_8B = not?exit&leave
  br-precmp-instr^ 3 + code-c@ c>s true ;

|: br-inc/dec-[ebp+n]?  ( disp -- flag )
  ilendb:last-len@ 3 = not?exit< drop false >?
  code-here 3 - code-w@ dup $45_FF = swap $4D_FF = or not?exit< drop false >?
  code-here 1- code-c@ c>s = ;

|: br-inc/dec-[esp+n]?  ( disp -- flag )
  ilendb:last-len@ dup 3 = ?exit< drop
    0= not?exit&leave
    code-here 3 - code-@ $FF_FF_FF and dup $24_04_FF = swap $24_0C_FF = or >?
  4 = not?exit< drop false >?
  code-here 4- code-@ $FF_FF_FF and dup $24_44_FF = swap $24_4C_FF = or not?exit< drop false >?
  code-here 1- code-c@ c>s = ;

|: br-good-inc/dec-cond?  ( jump-cond -- flag )
  << xasm:cond:z of?v| true |?
     xasm:cond:nz of?v| true |?
     xasm:cond:s of?v| true |?
     xasm:cond:ns of?v| true |?
  else| drop false >> ;

|: br-[esp+0]-ok?  ( disp reg -- flag )
  low:esp = swap  0= and ( disp)
  br-has-push-ebx? not and  low:stacks-swapped? and ;

|: br-rewrite-[ebp/esp]-compare  ( jump-cond disp reg -- jump-cond )
\ endcr ." BR-[EBP/ESP]-COMPARE at $" br-precmp-instr^ 1- .hex8 ."  type=" br-cmp-type 0.r cr
  ;; remove compare, load [addr], push ebx
  low:remove-last-unsafe low:remove-last-unsafe
  br-has-push-ebx? ?< low:remove-last-unsafe dup low:esp = ?< 4 under- >? >?
  br-cmp-type << ( jump-cond disp reg type )
    brcmp-test-ebx,ebx of?v| ( jump-cond disp reg )
      ;; "dec [reg+disp] / cmp [reg+disp], # 0 / jz/nz/s/ns" can be
      ;; optimised to just "dec", because it sets all necessary flags.
      ;; this is sometimes seen in various loops with a counter.
      pick2 br-good-inc/dec-cond? ?<
        dup low:ebp = ?< over br-inc/dec-[ebp+n]? || over br-inc/dec-[esp+n]? >?
\ dup ?< endcr ."   HIT-INC/DEC!\n" >?
      || false >?
      ( jump-cond disp reg skip-cmp? )
      ?< 2drop
      || ;; "cmp [esp+0], # 0 / pop ebx" --> " pop ebx / test ebx, ebx"
         \ over 0= ( disp)  over low:esp = and ( reg)
         \ br-has-push-ebx? not and  low:stacks-swapped? and
         2dup br-[esp+0]-ok?
         ?exit< \ endcr ." XXX-0 at $" code-here .hex8 cr
                2drop
                low:ebx low:pop-reg32
                low:test-ebx,ebx >?
         low:cmp-[ebp/esp+value],0 >? |?
    brcmp-cmp-eax,ebx of?v| ( jump-cond disp reg )
      2dup br-[esp+0]-ok?
      ?exit< \ endcr ."  XXX-1 at $" code-here .hex8 cr
             ;; "cmp eax, [esp+0] / pop ebx" --> " pop ebx / cmp eax, ebx"
             2drop
             low:ebx low:pop-reg32
             low:cmp-eax,ebx >?
      low:cmp-eax,[ebp/esp+value] |?
    brcmp-cmp-ebx,lit of?v| ( jump-cond disp reg )
      2dup br-[esp+0]-ok?
      ?exit< \ endcr ."  XXX-2 at $" code-here .hex8 cr
             ;; "cmp [esp+0], # n / pop ebx" --> " pop ebx / cmp ebx, # n"
             2drop
             low:ebx low:pop-reg32
             br-cmp-lit-value low:cmp-ebx,value >?
      br-cmp-lit-value low:cmp-[ebp/esp+value],value |?
  else| error" Succubus cannot compare strapons and booze" >>
  br-has-push-ebx? ?exit pop-tos ;


|: brxoptim-branch-push-pop  ( jump-cond -- jump-cond )
  low:stacks-swapped? not?exit< pop-tos >?  ;; just in case
  br-last-compare-type dup br-cmp-type:! not?exit< pop-tos >?
  2 ilendb:nth-last-type@ ilendb:it-push-ebx = dup br-has-push-ebx?:!
  ?< low:can-remove-last-3? || low:can-remove-last-2? >? not?exit< pop-tos >?
  code-here ilendb:last-len@ - ilendb:prev-last-len@ - br-precmp-instr^:!
  br-ebx-load-addr? ?exit< br-rewrite-[addr]-compare >?
  br-ebx-[ebp+n]? ?exit< low:ebp br-rewrite-[ebp/esp]-compare >?
  br-ebx-[esp+n]? ?exit< low:esp br-rewrite-[ebp/esp]-compare >?
  pop-tos ;


false quan brxoptim-remove-test?

;; "and ebx, lit / test ebx, ebx"
;; we don't need to generate a test
|: brxoptim-simple-and-lit  ( jump-cond 0 -- jump-cond 0 )
  code-here ilendb:last-len@ - code-w@
  dup $E3_83 = swap $E3_81 = or brxoptim-remove-test?:! ;

;; it is always safe
|: brxoptim-remove-last-test
  code-here ilendb:last-len@ - code-w@ $DB_85 = not?exit
\ endcr ."  BRX-AND at $" code-here ilendb:last-len@ - .hex8 cr
  low:remove-last-unsafe ;


;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; branch optimiser

: branch-cond-cg  ( tbl^ -- jump-cond )
  brxoptim-remove-test?:!f
  remove-last-push-tos?  ;; TRUE if "dup" was removed
  ?< ;; this is "dup brn", we need the proper boolean flag
     [ bropt-debug? ] [IF]
       bropt-active? ?< endcr ."  DUP REMOVED AT $" code-here .hex8 cr >?
     [ENDIF]
     stat-logbranch-blocked:1+!
     cdetect:reset-state 0  ( do not generate "pop tos") false
  || cdetect:detect-cond
     [ bropt-active? ] [IFNOT] drop 0 cdetect:reset-state
     [ELSE]
       \ dup not?< endcr ." COND-0 at $" code-here .hex8 cr >?
       [ bropt-debug? ] [IF]
         bropt-active? ?< endcr ." COND " dup . ." at $" code-here .hex8 cr >?
       [ENDIF]
       \ bropt-active? not?< drop 0 cdetect:reset-state >?
     [ENDIF]
     ;; statistics
     \ dup 0<> stat-logbranch-optimised:-!
     dup ?< stat-logbranch-optimised:1+! || brxoptim-simple-and-lit >?
     ( generate "pop tos") true >?
  nrot  ( gen-pop-tos? tbl^ cond-type )
  find-repl dup not?error" Succubus fell off the branch"
  [ bropt-debug? ] [IF]
    bropt-active? ?< endcr ."  REPL: $" dup .hex8 ."  [@]=$" dup @ .hex8 cr >?
  [ENDIF]
  repl-rec-rewrite  ( gen-pop-tos? jump-cond )
  [ bropt-debug? ] [IF]
    bropt-active? ?< endcr ."   JUMP-COND: " dup 0.r cr >?
  [ENDIF]
  brxoptim-remove-test? ?< brxoptim-remove-last-test >?
  swap ?exit< brxoptim-branch-push-pop >? ;
